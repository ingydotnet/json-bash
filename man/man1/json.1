.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "\&\s-1JSON 1"
.TH \&\s-1JSON 1 "March 2016" "Generated by Swim v0.1.43" "JSON\s0 for Bash"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
\&\s-1JSON \- JSON\s0 for Bash
.PP
<badge travis ingydotnet/json\-bash>
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&    source json.bash
\&
\&    json=\*(Aq{"name":"Jason","friends":["Jimmy","Joe"]}\*(Aq
\&    JSON.load "$json"
\&    joe=$(JSON.get /friends/1)
\&    JSON.put /friends/2 Jeff
\&    new_json=$(JSON.dump)
.Ve
.SH "Description"
.IX Header "Description"
The \f(CW\*(C`json.bash\*(C'\fR library provides functions for loading, manipulating and dumping \s-1JSON\s0 data.
.PP
Bash doesn't have nestable hashes and arrays to load \s-1JSON\s0 data into. This library provides a different data model called a \*(L"linear tree\*(R". A linear tree is simply a sequence of text lines, each containing a key-path and a leaf-value (separated by a tab):
.PP
.Vb 1
\&    /key/path<HARD\-TAB>"leaf value"
.Ve
.PP
Thus this \s-1JSON:\s0
.PP
.Vb 11
\&    {
\&      "name": {
\&        "first": "Jimmy",
\&        "last": "James"
\&      },
\&      "list": [
\&        "A string",
\&        42,
\&        [ true, false, null ]
\&      ]
\&    }
.Ve
.PP
Would be loaded as this linear tree:
.PP
.Vb 7
\&    /name/first "Jimmy"
\&    /name/last  "James"
\&    /list/0     "A string"
\&    /list/1     42
\&    /list/2/0   true
\&    /list/2/1   false
\&    /list/2/2   null
.Ve
.PP
Since Bash has many tools for searching and manipulating text, the linear form works fairly well for common \s-1JSON\s0 data operations.
.SH "Installation"
.IX Header "Installation"
Just run:
.PP
.Vb 1
\&    make install
.Ve
.PP
This may require \f(CW\*(C`sudo\*(C'\fR permission.
.PP
By default, this will install:
.PP
.Vb 2
\&    /usr/local/lib/bash/test\-simple.bash
\&    /usr/local/share/man/man1/test\-simple.1
.Ve
.PP
You can change the install locations with these environment variables:
.IP "\(bu" 4
\&\f(CW\*(C`PREFIX\*(C'\fR \- default is \f(CW\*(C`/usr/local\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`INSTALL_LIB\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`INSTALL_MAN\*(C'\fR
.PP
Run \f(CW\*(C`make help\*(C'\fR to see all the \f(CW\*(C`make\*(C'\fR targets that are available.
.SH "API Functions"
.IX Header "API Functions"
The library contains functions to \fBload\fR \s-1JSON\s0 to the linear form and to \fBdump\fR that form back into \s-1JSON.\s0 It also has functions to retrieve, modify, add and remove data from the linear form.
.ie n .IP """JSON.load [ <json\-string> [<linear\-var\-name>]]""" 4
.el .IP "\f(CWJSON.load [ <json\-string> [<linear\-var\-name>]]\fR" 4
.IX Item "JSON.load [ <json-string> [<linear-var-name>]]"
This function takes \s-1JSON\s0 as input and generates a linear tree as output.
.Sp
With no arguments, input is read from stdin and output is written to stdout. With one argument, the input is provided as a string argument and the output is stored in an internal cache variable. With two arguments the input is again provided as a string argument, and the output is copied into the variable name provided.
.ie n .IP """JSON.dump [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.dump [<linear\-var\-name>]\fR" 4
.IX Item "JSON.dump [<linear-var-name>]"
This function takes a linear tree as input and generates \s-1JSON\s0 as output.
.Sp
With no arguments, input is read from stdin. With one argument, input is taken from the provided variable name. To use the internal cache, use \f(CW\*(C`\-\*(C'\fR as the variable name. Output is always written to stdout. Formatting of the output can be set using \s-1JSON\s0.style (see below).
.ie n .IP """JSON.style minimal|normal|pretty [<indent\-string>]""" 4
.el .IP "\f(CWJSON.style minimal|normal|pretty [<indent\-string>]\fR" 4
.IX Item "JSON.style minimal|normal|pretty [<indent-string>]"
This function sets style of output formatting for all subsequent calls to \s-1JSON\s0.dump.
.Sp
There are three different styles available:
.Sp
.Vb 3
\&    * \`minimal\` \- single line, no unnecessary whitespace
\&    * \`normal\` \- single line, keys and values separated by single space
\&    * \`pretty\` \- one value per line, indented
.Ve
.Sp
Before first call to this function, the style is set to \*(L"normal\*(R". The second argument is only honored for \*(L"pretty\*(R" formatting style.
.ie n .IP """JSON.get [\-a|\-s|\-b|\-n|\-z] <key\-path> [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.get [\-a|\-s|\-b|\-n|\-z] <key\-path> [<linear\-var\-name>]\fR" 4
.IX Item "JSON.get [-a|-s|-b|-n|-z] <key-path> [<linear-var-name>]"
This function takes a key path and returns the corresponding value. If the key is found, the exit status is 0, otherwise it is 1. If the value is a string, it will be enclosed in double quotes. Otherwise it will be a number or the unquoted strings: \f(CW\*(C`true\*(C'\fR, \f(CW\*(C`false\*(C'\fR or \f(CW\*(C`null\*(C'\fR.
.Sp
With just the one required argument, the linear tree will be obtained from stdin. Otherwise it can be provided with a variable name (or \f(CW\*(C`\-\*(C'\fR for the cache). The value (if any) is written to stdout.
.Sp
See \s-1FLAGS\s0 below for an explanation of the flag options.
.ie n .IP """JSON.keys <key\-path> [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.keys <key\-path> [<linear\-var\-name>]\fR" 4
.IX Item "JSON.keys <key-path> [<linear-var-name>]"
This function takes a key path and returns the keys of the corresponding object, one per line. If the key is not found or the value of the key is not an object, it will return nothing.
.ie n .IP """JSON.object <key\-path> [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.object <key\-path> [<linear\-var\-name>]\fR" 4
.IX Item "JSON.object <key-path> [<linear-var-name>]"
This function takes a key path and returns the corresponding object. If the key is not found, it will return nothing.
.ie n .IP """JSON.put [\-s|\-b|\-n|\-z] <key\-path> <new\-value> [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.put [\-s|\-b|\-n|\-z] <key\-path> <new\-value> [<linear\-var\-name>]\fR" 4
.IX Item "JSON.put [-s|-b|-n|-z] <key-path> <new-value> [<linear-var-name>]"
This function adds a path/value pair to the linear tree. If the path already exists, the value will be replaced, otherwise it will be added.
.Sp
With just the two required arguments, the linear tree will be obtained from stdin. Otherwise it can be provided with a variable name (or \f(CW\*(C`\-\*(C'\fR for the cache). Nothing will be written to stdout and the exit status will always be 0.
.ie n .IP """JSON.del <key\-path> <new\-value> [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.del <key\-path> <new\-value> [<linear\-var\-name>]\fR" 4
.IX Item "JSON.del <key-path> <new-value> [<linear-var-name>]"
This function removes a path/value pair from the linear tree, if it exists.
.Sp
With just the one required argument, the linear tree will be obtained from stdin. Otherwise it can be provided with a variable name (or \f(CW\*(C`\-\*(C'\fR for the cache). Nothing will be written to stdout and the exit status will always be 0.
.Sp
Heuristics will be used to determine what type the value is. The \-s flag indicates the value is a string, the \-n flag indicates a number,the \-b flag indicates a boolean and the \-z flag indicates a null value.
.ie n .IP """JSON.cache [<linear\-var\-name>]""" 4
.el .IP "\f(CWJSON.cache [<linear\-var\-name>]\fR" 4
.IX Item "JSON.cache [<linear-var-name>]"
Outputs the value of the internal linear tree cache string.
.Sp
With no arguments, the value is written to stdout. With one argument, the value is copied to the variable name provided.
.SH "Flags"
.IX Header "Flags"
The command flags \f(CW\*(C`\-a\*(C'\fR, \f(CW\*(C`\-s\*(C'\fR, \f(CW\*(C`\-n\*(C'\fR, \f(CW\*(C`\-b\*(C'\fR and \f(CW\*(C`\-z\*(C'\fR indicate the \fBtype\fR of value provided or expected, and they refer to Any, String, Number, Boolean and Null respectively. If the type of data doesn't look like the type indicated by the flag, the command will return with a status code of 2.
.PP
If \f(CW\*(C`\-a\*(C'\fR is used, the double quotes at each end (if any) will be removed for a \f(CW\*(C`JSON.get\*(C'\fR.
.PP
If \f(CW\*(C`\-s\*(C'\fR is used and the data is a string, the double quotes will be removed for a \f(CW\*(C`JSON.get\*(C'\fR or added for a \f(CW\*(C`JSON.put\*(C'\fR.
.PP
The \f(CW\*(C`\-n\*(C'\fR flag requires no value transformation, but it will cause the command to fail (status 2) if the value is not a number.
.PP
If \f(CW\*(C`\-b\*(C'\fR is used for a \f(CW\*(C`JSON.get\*(C'\fR, true will become 0 and false will become 1. \f(CW\*(C`JSON.put\*(C'\fR will do the reverse. This follows Bash's idea of using 0 for a successful return code.
.PP
The \f(CW\*(C`\-z\*(C'\fR flag on a \f(CW\*(C`JSON.get\*(C'\fR will turn \f(CW\*(C`null\*(C'\fR into the empty string, and for a \f(CW\*(C`JSON.put\*(C'\fR will turn any value into \f(CW\*(C`null\*(C'\fR.
.SH "Examples"
.IX Header "Examples"
.Vb 4
\&    # Load JSON to linear tree
\&    JSON.load "$(< file.json)" tree
\&    # or:
\&    tree=$(cat file.json | JSON.load)
\&
\&    # Get a value
\&    first_name=$(JSON.get /name/first tree)
\&    # or:
\&    first_name=$(echo "$tree" | JSON.get /name/first)
\&
\&    # Change a value
\&    JSON.put /name/first Jimmy tree
\&    # or:
\&    tree=(echo "$tree" | JSON.put /name/first Jimmy)
\&
\&    # Delete a value
\&    JSON.del /name/middle tree
\&    # or:
\&    tree=(echo "$tree" | JSON.del /name/middle)
\&
\&    # Dump a linear tree to JSON
\&    JSON.dump tree > new\-file.json
\&    # or:
\&    echo "$tree" | JSON.dump > new\-file.json
.Ve
.SH "Problems"
.IX Header "Problems"
This library is meant to be useful for solving common problems involving \s-1JSON.\s0 However, without the native \s-1JSON\s0 object model in Bash, it becomes problematic the further you stray from the norm.
.PP
Here is a list of known issues. Some may be addressed, some are very likely to stay out of scope:
.IP "\(bu" 4
No support for empty arrays and empty objects.
.IP "\(bu" 4
No support for key-paths that refer to objects or arrays.
.IP "\(bu" 4
No support for common array operations like \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`splice\*(C'\fR, etc.
.SH "Todo"
.IX Header "Todo"
.IP "\(bu" 4
Support object keys that:
.RS 4
.IP "\(bu" 4
Contain whitespace
.IP "\(bu" 4
Consist of all digit characters
.IP "\(bu" 4
Contain backslashes
.RE
.RS 4
.RE
.IP "\(bu" 4
Implement \s-1JSON\s0.dump
.SH "Status"
.IX Header "Status"
Please report any issues to <https://github.com/ingydotnet/json\-bash/issues>
.PP
Or find me on ingy@irc.freenode.net.
.SH "Author"
.IX Header "Author"
Written by Ingy döt Net <ingy@ingy.net>
.SH "Copyright & License"
.IX Header "Copyright & License"
Copyright 2013\-2016 Ingy döt Net
.PP
The \s-1MIT\s0 License (\s-1MIT\s0)
